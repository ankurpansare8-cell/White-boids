<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Interactive Smoke & Ash Flow</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
</head>
<body>
<script>
let boids = [];
let ashes = [];
let noiseZ = 0;

const NUM_BOIDS = 60;
const NUM_ASHES = 900;

function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);
  noStroke();

  // init "boids" for background pattern
  for (let i = 0; i < NUM_BOIDS; i++) {
    boids.push(new Boid(random(width), random(height)));
  }

  // init ash/smoke particles
  for (let i = 0; i < NUM_ASHES; i++) {
    ashes.push(new Ash(random(width), random(height)));
  }

  background(0);
}

function draw() {
  // soft fade to keep trails
  noStroke();
  fill(0, 40);
  rect(0, 0, width, height);

  noiseZ += 0.003;

  // draw boid-like background pattern
  for (let b of boids) {
    b.update();
  }
  drawBoidConnections();

  // draw smoke/ash particles
  for (let a of ashes) {
    a.update();
    a.show();
  }
}

// -----------------------------
// Boid-ish points for background
// -----------------------------
class Boid {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.off = random(1000);
  }

  update() {
    // perlin-driven drift
    let n = noise(this.pos.x * 0.001, this.pos.y * 0.001, this.off + noiseZ);
    let angle = n * TWO_PI * 2;
    let speed = 0.6;

    this.pos.x += cos(angle) * speed;
    this.pos.y += sin(angle) * speed;

    // wrap edges
    if (this.pos.x < 0) this.pos.x += width;
    if (this.pos.x > width) this.pos.x -= width;
    if (this.pos.y < 0) this.pos.y += height;
    if (this.pos.y > height) this.pos.y -= height;
  }
}

function drawBoidConnections() {
  strokeWeight(1);
  for (let i = 0; i < boids.length; i++) {
    let b1 = boids[i];
    for (let j = i + 1; j < boids.length; j++) {
      let b2 = boids[j];
      let d = p5.Vector.dist(b1.pos, b2.pos);
      if (d < 120) {
        let alpha = map(d, 0, 120, 70, 0);
        stroke(80, 80, 80, alpha);
        line(b1.pos.x, b1.pos.y, b2.pos.x, b2.pos.y);
      }
    }
  }
}

// -----------------------------
// Ash / smoke particles
// -----------------------------
class Ash {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.vel = p5.Vector.random2D().mult(0.2);
    this.glow = random(0.2); // baseline brightness
  }

  update() {
    // flow field via Perlin noise
    let n = noise(this.pos.x * 0.002, this.pos.y * 0.002, noiseZ);
    let angle = n * TWO_PI * 3;
    let dir = createVector(cos(angle), sin(angle));

    this.vel.lerp(dir.mult(1.3), 0.08);
    this.pos.add(this.vel);

    // gentle ambient flicker from noise
    let ambient = n * 0.5;
    this.glow = max(this.glow * 0.96, ambient * 0.7);

    // mouse interaction: brighten & swirl near click
    if (mouseIsPressed) {
      let d = dist(this.pos.x, this.pos.y, mouseX, mouseY);
      if (d < 150) {
        let push = p5.Vector.sub(this.pos, createVector(mouseX, mouseY));
        push.setMag(map(d, 0, 150, 2.2, 0.1));
        this.vel.add(push);
        this.glow = 1.6; // strong light-up
      }
    }

    // keep inside bounds (wrap)
    if (this.pos.x < 0) this.pos.x += width;
    if (this.pos.x > width) this.pos.x -= width;
    if (this.pos.y < 0) this.pos.y += height;
    if (this.pos.y > height) this.pos.y -= height;
  }

  show() {
    // tiny, high-detail particles
    let g = 40 + this.glow * 180;      // brightness
    let alpha = 70 + this.glow * 140;  // opacity
    let size = 1.3 + this.glow * 2.2;  // size

    noStroke();
    fill(g, g, g, alpha);

    // slight soft halo
    ellipse(this.pos.x, this.pos.y, size, size);
  }
}

// -----------------------------
// Resize on window change
// -----------------------------
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
